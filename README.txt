Chris MacDonald
November 4, 2015
Programming Languages

Type Systems and Semantic Analysis

This program was written in Sublime in C++.  It was compiled and run in the Terminal application.  This program consists of the "semantics.cc" source code file.  This file contains a main method which processes an input file.  The input file should contain a list of tokens and their corresponding lexemes, with one token and one lexeme per line, separated by a tab character.  The main function then calls a series of other functions also contained in "semantics.cc" that detect any type errors in the stream of tokens and lexemes.  While checking for type errors, these functions also perform a semantic analysis of the program and keep track of the state of its variables.  Most of these subsequent functions (all but "addSymbol") correspond to production rules from an EBNF grammar for the CLite language.  

To run semantics.cc in Terminal, use these 2 commands:

1) compile semantics.cc with the command:	g++ -Wall -o semantics semantics.cc

2) run the code with the command: 		./semantics input.txt

NOTE: here "input.txt" is a text file containing tokens and lexemes formatted in the way described above

When the code runs, it produces output in the terminal window.  If there is a type error, the program prints it out in the terminal window and exits immediately.  The program also produces output generated by print statements in the input CLite file.  

Notes on design:  

One key design feature of this program was the Heterogeneous object (provided by Prof. Irfan).  This object holds a string noting the type or a variable or expression as well as a value for that variable or expression. The value can be an int, float, bool, or char value.  To keep track of the type and value of expressions, I had the factor, term, addition, relation, equality, conjunction, and expression functions all return Heterogeneous objects. 

I implemented the symbol table as a map of Heterogeneous objects.  The keys in the map were variable identifiers.  I added variables to the symbol table as they were declared.  Nearly every time there was an assignment, I updated the appropriate value in the symbol table.  The exception here was when the assignment occurred as a part of a statement contained in an if-statement or while-loop with a false condition.  In these cases, I did not change the semantic state of the program.  To account for while loops, I would save the current token number right before parsing the conditional expression for the loop.  This way, if the condition was true I could go back to the saved token number and parse the same expression again and again until it was false.  Every time the while loop condition is true, the program executes the statement inside the loop, and so the semantic state of the program changes.  

